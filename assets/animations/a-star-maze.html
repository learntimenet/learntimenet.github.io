<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>A* Pathfinding â€“ With Legend & Valid Maze</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }
    #legend {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      font-size: 14px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .color-box {
      width: 16px;
      height: 16px;
      border: 1px solid #444;
    }
  </style>
</head>
<body>

<div id="legend">
  <div class="legend-item"><div class="color-box" style="background: blue;"></div>Start</div>
  <div class="legend-item"><div class="color-box" style="background: gold;"></div>End</div>
  <div class="legend-item"><div class="color-box" style="background: red;"></div>Closed Set</div>
  <div class="legend-item"><div class="color-box" style="background: blue;"></div>Open Set</div>
  <div class="legend-item"><div class="color-box" style="background: lime;"></div>Path</div>
  <div class="legend-item"><div class="color-box" style="background: black;"></div>Wall</div>
</div>

<canvas id="canvas" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const cols = 30;
const rows = 30;
const grid = [];
const openSet = [];
const closedSet = [];
let path = [];

const cellSize = canvas.width / cols;

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.f = 0;
    this.g = 0;
    this.h = 0;
    this.neighbors = [];
    this.previous = undefined;
    this.wall = false;
  }

  draw(color) {
    ctx.fillStyle = this.wall ? "#000" : color;
    ctx.fillRect(this.x * cellSize, this.y * cellSize, cellSize - 1, cellSize - 1);
  }

  addNeighbors(grid) {
    const { x, y } = this;
    if (x < cols - 1) this.neighbors.push(grid[x + 1][y]);
    if (x > 0) this.neighbors.push(grid[x - 1][y]);
    if (y < rows - 1) this.neighbors.push(grid[x][y + 1]);
    if (y > 0) this.neighbors.push(grid[x][y - 1]);
  }
}

function heuristic(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

// Create grid
for (let x = 0; x < cols; x++) {
  grid[x] = [];
  for (let y = 0; y < rows; y++) {
    grid[x][y] = new Cell(x, y);
  }
}
for (let x = 0; x < cols; x++) {
  for (let y = 0; y < rows; y++) {
    grid[x][y].addNeighbors(grid);
  }
}

const start = grid[0][0];
const end = grid[cols - 1][rows - 1];
start.wall = false;
end.wall = false;
openSet.push(start);

// Randomly assign walls with guaranteed path using DFS
function generateMazeDFS(cell, visited = new Set()) {
  const key = `${cell.x},${cell.y}`;
  visited.add(key);

  const shuffled = [...cell.neighbors].sort(() => 0.5 - Math.random());
  for (let neighbor of shuffled) {
    const nKey = `${neighbor.x},${neighbor.y}`;
    if (!visited.has(nKey)) {
      neighbor.wall = false; // clear path
      generateMazeDFS(neighbor, visited);
    }
  }
}

// Initially set all to walls, then carve a path
for (let x = 0; x < cols; x++) {
  for (let y = 0; y < rows; y++) {
    grid[x][y].wall = true;
  }
}
start.wall = false;
generateMazeDFS(start);

// After path exists, randomly open more walls to make it a maze
for (let x = 0; x < cols; x++) {
  for (let y = 0; y < rows; y++) {
    if (Math.random() < 0.3) grid[x][y].wall = false;
  }
}
start.wall = false;
end.wall = false;

let solving = true;
let found = false;

function draw() {
  if (solving) {
    if (openSet.length > 0) {
      let lowest = 0;
      for (let i = 1; i < openSet.length; i++) {
        if (openSet[i].f < openSet[lowest].f) lowest = i;
      }

      const current = openSet[lowest];

      if (current === end) {
        found = true;
        solving = false;
        path = [];
        let temp = current;
        path.push(temp);
        while (temp.previous) {
          path.push(temp.previous);
          temp = temp.previous;
        }
        console.log("Path found!");
      }

      openSet.splice(lowest, 1);
      closedSet.push(current);

      current.neighbors.forEach(neighbor => {
        if (!closedSet.includes(neighbor) && !neighbor.wall) {
          const tempG = current.g + 1;
          let newPath = false;
          if (openSet.includes(neighbor)) {
            if (tempG < neighbor.g) {
              neighbor.g = tempG;
              newPath = true;
            }
          } else {
            neighbor.g = tempG;
            newPath = true;
            openSet.push(neighbor);
          }

          if (newPath) {
            neighbor.h = heuristic(neighbor, end);
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.previous = current;
          }
        }
      });
    } else {
      console.log("No solution");
      solving = false;
    }
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let x = 0; x < cols; x++) {
    for (let y = 0; y < rows; y++) {
      grid[x][y].draw("white");
    }
  }

  closedSet.forEach(cell => cell.draw("red"));
  openSet.forEach(cell => cell.draw("blue"));

  if (found) {
    path.forEach(cell => cell.draw("lime"));
  }

  start.draw("blue");
  end.draw("gold");

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
